#!/usr/bin/env bash

# Commands that should be applied only for interactive shells.
[[ $- == *i* ]] || return

shopt -s globstar
shopt -s histappend

# shellcheck disable=SC1091
source "$XDG_DATA_HOME/meowgorithm/bash_funcs"

# shellcheck disable=1090
env="$XDG_DATA_HOME/meowgorithm/env.asc"
# shellcheck disable=SC1090
[ -f "$env" ] && source <(gpg --decrypt "$env" 2>/dev/null)

export HISTCONTROL=ignorespace:ignoredups:erasedups
export HISTFILESIZE=100000
export HISTSIZE=10000
export HISTIGNORE="ls:cd:pwd:clear:exit:history:shutdown:reboot"
export PROMPT_DIRTRIM=2
export CLICOLOR=1

# Where our dotfiles repo lives
export DOTFILES="$HOME/.dotfiles"

os="$(which_os)"

# Look for git-prompt and setup the first one we find
gitPromptPaths=(
    "/usr/share/git-core/contrib/completion/git-prompt.sh" # fedora
    "/usr/share/git/git-prompt.sh"                         # void
)
for path in "${gitPromptPaths[@]}"; do
    # shellcheck disable=SC1090
    [[ -f "$path" ]] && source "$path" && break
done

# Load bash completion if available
if ! shopt -oq posix; then
    bashCompletionPaths=(
        "/usr/share/bash-completion/bash_completion"
        "/etc/bash_completion"
    )
    for path in "${bashCompletionPaths[@]}"; do
        # shellcheck disable=SC1090
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# OS/Distro specific stuff
case "$os" in
fedora)
    alias zzz="sudo systemctl suspend"
    alias enable="sudo systemctl enable --now"
    alias status="sudo systemctl status"
    alias start="sudo systemctl start"
    alias stop="sudo systemctl stop"
    alias restart="sudo systemctl restart"
    alias go-task="task"
    ;;

nixos)
    alias ls='ls --color=auto'
    alias zzz="sudo systemctl suspend"

    # Git prompt on NixOS
    # shellcheck disable=1090
    for f in /nix/store/*-git-*/share/git/contrib/completion/git-prompt.sh; do
        [[ -f "$f" ]] && source "$f" && break
    done
    ;;

darwin)
    eval "$(/opt/homebrew/bin/brew shellenv)"

    # shellcheck disable=1091
    gitCompletionPath="$(brew --prefix)/opt/git/share/bash-completion/completions/git"
    if [[ -e $gitCompletionPath ]]; then
        # shellcheck disable=SC1090
        source "$gitCompletionPath"
    fi

    gitPS1Path="$(brew --prefix)/opt/git/etc/bash_completion.d/git-prompt.sh"
    if [[ -e $gitPS1Path ]]; then
        # shellcheck disable=SC1090
        source "$gitPS1Path"
    fi

    # Make sure XDG_CONFIG_HOME is a thing
    if [[ -z $XDG_CONFIG_HOME ]]; then
        export XDG_CONFIG_HOME="$HOME/.config"
    fi
    mkdir -p "$XDG_CONFIG_HOME"

    export LSCOLORS=dxfxcxdxbxegedabagacad
    alias ls='ls -h'

    # Keep TAR from tarring-up resource forks
    export COPYFILE_DISABLE=true

    # Miscellaneous aliases
    alias brew-remove="brew list | sort | gum filter --no-limit | xargs brew remove"

    # Colored man pages
    export LESS_TERMCAP_mb=$'\E[01;31m'
    export LESS_TERMCAP_md=$'\E[01;31m'
    export LESS_TERMCAP_me=$'\E[0m'
    export LESS_TERMCAP_se=$'\E[0m'
    export LESS_TERMCAP_so=$'\E[01;44;33m'
    export LESS_TERMCAP_ue=$'\E[0m'
    export LESS_TERMCAP_us=$'\E[01;32m'
    ;;

esac

function nixPrompt() {
    case $IN_NIX_SHELL in
    pure) printf ' <nix>' ;;
    impure) printf ' <nix*>' ;;
    *) printf '' ;;
    esac
}

red='\[\e[0;31m\]'
yellow='\[\e[0;33m\]'
cyan='\[\e[0;36m\]'
violet='\[\e[38;5;63m\]'
no_color='\[\e[0m\]'
indigo='\[\e[38;2;90;86;224m\]'

function prompt_func() {
    nix=$(nixPrompt)
    dimensions="$(tput cols)×$(tput lines)"
    git_branch=$(__git_ps1 " (%s)")

    if [[ -n $DEMO_PROMPT ]]; then
        PS1="$indigo>$no_color "
    else
        PS1="$indigo$dimensions $cyan\h:$red\w $cyan\u$yellow$git_branch$violet$nix $red\$ $no_color"
    fi
}

PROMPT_COMMAND=prompt_func

export GPG_TTY=$(tty)

alias nb='nix build -L'
alias nr='nix run -L -j"$(num_cores)"'
alias nrm='nix run -L -j"$(num_cores)" 2>&1 | tee >(mods "What does this NixOS output mean?")'
alias code-review='git --no-pager diff | mods -f "code review this patch" | glow'
alias filterkill='ps | awk "NR>1" | gum choose --header="  Kill Process?" | xargs kill'
alias tree='tree -C'

# Helper vars
export MEOW='git@github.com:meowgorithm'
export GITLAB='git@gitlab.com:meowgorithm'
export CHARM='git@github.com:charmbracelet'
export GOCHARM='github.com/charmbracelet'

# shellcheck disable=1091
if test -n "$KITTY_INSTALLATION_DIR" -a -e "$KITTY_INSTALLATION_DIR/shell-integration/bash/kitty.bash"; then
    source "$KITTY_INSTALLATION_DIR/shell-integration/bash/kitty.bash"
fi

# Go
export GOPATH="$HOME/.go"
export GOTOOLCHAIN="auto"

# GHCUP
# shellcheck disable=1091
[ -f "$HOME/.ghcup/env" ] && . "$HOME/.ghcup/env"

# Direnv
command -v direnv >/dev/null 2>&1 && eval "$(direnv hook bash)"

# Find lua executable
lua_path=$(command -v lua 2>/dev/null)
if [[ -z "$lua_path" ]]; then
    for f in /nix/store/*-lua-*/bin/lua; do
        [[ -x "$f" ]] && lua_path="$f" && break
    done
fi

# Find z.lua script and initialize
if [[ -n "$lua_path" ]]; then
    z_lua_path=""
    for path in \
        "$(brew --prefix 2>/dev/null)/opt/z.lua/share/z.lua/z.lua" \
        "$HOME/.local/share/z.lua/z.lua"; do
        [[ -f "$path" ]] && z_lua_path="$path" && break
    done

    # Check nix store if not found
    if [[ -z "$z_lua_path" ]]; then
        for f in /nix/store/*-z.lua-*/share/z.lua/z.lua; do
            [[ -f "$f" ]] && z_lua_path="$f" && break
        done
    fi

    [[ -n "$z_lua_path" ]] && eval "$("$lua_path" "$z_lua_path" --init bash)"
fi

paths=(
    "$HOME/.local/bin"
    "$HOME/.nix-profile/bin"
    "$HOME/.cargo/bin"
    "$HOME/.ghcup/bin"
    "$GOPATH/bin"
    "$HOME/.bin"
)

# Add paths to the PATH. Note that we ensure the path exists and isn’t already
# in the PATH.
for dir in "${paths[@]}"; do
    if [[ -d $dir && ":$PATH:" != *":$dir:"* ]]; then
        PATH="${PATH:+"$PATH:"}$dir"
    fi
done

# Prioritize /usr/bin on macOS
if [[ "$os" == "darwin" ]]; then
    export PATH="/usr/bin:$PATH"
fi
