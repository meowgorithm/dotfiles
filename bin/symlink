#!/usr/bin/env bash

os="$(which_os)"

symlinksFile="$DOTFILES/symlinks.yml"

# Ensure the given programs exists, exiting with error if not.
#
# Example:
#     require sponge realpath
function require() {
    for arg in "$@"; do
        if [[ "$(command_exists "$arg")" != 1 ]]; then
            printf '%s is required. Please install it and try again.\n' "$arg"
            exit 1
        fi
    done
}

# Get symlinks as key-value pairs, one per line. Common symlinks are merged
# into the target group.
#
# Example:
#     getSymlinkGroup void
function getSymlinks() {
    yq e ".common *+ .$1 | .[] | .src + \" \" + .dst" "$symlinksFile"
}

# Perform symlinking, removing any existing file or directory at the
# destination. The local path is relative to the repository root. The remote
# path is relative to the user's home directory.
#
# Example:
#     link myCuteBashrc .bashrc
function link() {
    local src="$DOTFILES/$1"
    local dst="$HOME/$2"

    if [[ ! -f $src && ! -d $src ]]; then
        printf 'Warning:\n    %s does not exist\n    ...so we cannot symlink it to %s\n' "$src" "$dst"
        return 1
    fi

    rm -rf "$dst"
    ln -s "$src" "$dst"
}

require dirname realpath yq

if [[ ! -f "$symlinksFile" ]]; then
    printf 'Error: %s not found' "$symlinksFile"
    exit 1
fi

mkdir -p "$HOME/.config"

IFR=''
while read -r line; do
    read -a pairs <<< "$line"
    link "${pairs[0]}" "${pairs[1]}"
    if [[ $? == 0 ]]; then
        printf "Symlinked: %s -> %s\n" "${pairs[0]}" "${pairs[1]}"
    fi
done <<< "$(getSymlinks "$os")"
