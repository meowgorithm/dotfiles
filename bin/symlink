#!/usr/bin/env bash

#set -x

basedir=$(dirname "$(realpath ~/.bashrc)")
os="$($basedir/utils/which-os)"

symlinksFile="$basedir/symlinks.yml"

# Ensure the given programs exists, exiting with error if not.
#
# Example:
#     require sponge realpath
function require() {
    for arg in "$@"; do
        if [[ ! "$("$basedir/utils/command-exists" "$arg")" ]]; then
            printf '%s is required. Please install it and try again.\n' $arg
            exit 1
        fi
    done
}

# Get symlinks as key-value pairs, one per line. Common symlinks are merged
# into the target group.
#
# Example:
#     getSymlinkGroup void
function getSymlinks() {
    yq e ".common *+ .$1 | .[] | .src + \" \" + .dst" "$symlinksFile"
}

# Perform symlinking, removing any existing file or directory at the
# destination. The local path is relative to the repository root. The remote
# path is relative to the user's home directory.
#
# Example:
#     link myCuteBashrc .bashrc
function link() {
    local src="$basedir/$1"
    local dst="$HOME/$2"

    if [[ ! -f $src && ! -d $src ]]; then
        printf 'Warning:\n    %s does not exist\n    ...so we cannot symlink it to %s\n' "$src" "$dst"
        return 1
    fi

    rm -rf "$dst"
    ln -s "$src" "$dst"
}

require dirname realpath yq

if [[ ! -f "$symlinksFile" ]]; then
    printf 'Error: %s not found' "$symlinksFile"
    exit 1
fi

mkdir -p "$HOME/.config"

IFR=''
while read -r line; do
    read -a pairs <<< "$line"
    link "${pairs[0]}" "${pairs[1]}"
    if [[ $? == 0 ]]; then
        printf "Symlinked: ${pairs[0]} -> ${pairs[1]}\n"
    fi
done <<< $(getSymlinks "$os")
